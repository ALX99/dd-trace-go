// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016 Datadog, Inc.

package main

import (
	"fmt"
	"go/types"
	"log"
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

const domainstate = "github.com/datadog/dd-trace-go/dyngo/internal/domainstate"

var (
	headerComment = strings.Join([]string{
		"// Unless explicitly stated otherwise all files in this repository are licensed",
		"// under the Apache License Version 2.0.",
		"// This product includes software developed at Datadog (https://www.datadoghq.com/).",
		"// Copyright 2023 Datadog, Inc.",
		"",
		"// Code generated by 'go run github.com/datadog/dd-trace-go/dyngo/internal/domainstate/generator' DO NOT EDIT",
	}, "\n")
)

func main() {
	var domains []string
	if pkgs, err := packages.Load(&packages.Config{Mode: packages.NeedTypes | packages.NeedTypesInfo}, domainstate); err != nil {
		log.Fatalf("Failed to load types from %q: %v\n", domainstate, err)
	} else {
		pkg := pkgs[0]
		domainType := fmt.Sprintf("%s.Domain", domainstate)
		for _, def := range pkg.TypesInfo.Defs {
			if def == nil || !def.Exported() || def.Type().String() != domainType {
				continue
			}
			if _, ok := def.(*types.Const); ok {
				domains = append(domains, def.Id())
			}
		}
	}
	sort.Strings(domains)

	file := jen.NewFile("domain")
	file.HeaderComment(headerComment)

	file.Comment("//go:generate go run github.com/datadog/dd-trace-go/dyngo/internal/domainstate/generator\n")

	file.Type().Id("Domain").Op("=").Qual(domainstate, "Domain")

	file.Const().DefsFunc(func(g *jen.Group) {
		for _, domain := range domains {
			g.Id(domain).Op("=").Qual(domainstate, domain)
		}
	})

	if err := file.Save("domain.go"); err != nil {
		log.Fatalln(err)
	}
}
